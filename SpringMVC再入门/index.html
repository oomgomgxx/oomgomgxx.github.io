<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="DeeTam" />
  <meta name="description" content="学然后知不足" />
  
  
  <title>
    
      Spring MVC再入门 
      
      
    
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Montserrat|Roboto:400,400italic,600|Roboto+Mono" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">


  

  
    
<link rel="stylesheet" href="/css/post.css">

  

  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <a href="/">DEE TAM</a>
</div>


      <p class="links">
  
    <a title="归档" target="" href="/archives/">
      <i class="iconfont icon-bookmark"></i>
    </a>
  
    <a title="邮箱" target="" href="mailto:oomgomgxx@gmail.com">
      <i class="iconfont icon-envelope"></i>
    </a>
  
    <a title="QQ" target="" href="tencent://message/?Menu=yes&uin=0x1DACE601&Service=300&sigT=45a1e5847943b64c6ff3990f8a9e644d2b31356cb0b4ac6b24663a3c8dd0f8aa12a595b1714f9d45">
      <i class="iconfont icon-qq"></i>
    </a>
  
    <a title="关于" target="" href="/about/">
      <i class="iconfont icon-emoji-friendly"></i>
    </a>
  
</p>


      <div class="main">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>

<div class="post">
  
  <!--
  
    <h3 class="date">
    Oct 19, 2020
  </h3>
  
  -->

  
  <center>
    <h1>
      Spring MVC再入门
    </h1>
  </center>
  

  <div class="content markdown-body">
    <h2 id="内容修订"><a href="#内容修订" class="headerlink" title="内容修订"></a>内容修订</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>温故而知新。</p>
<p>研究源码不建议基于 SpringBoot，着手搭建框架有利于熟悉内部组件。</p>
<h2 id="快速搭建基于-Servlet-3-的-Web-项目"><a href="#快速搭建基于-Servlet-3-的-Web-项目" class="headerlink" title="快速搭建基于 Servlet 3 的 Web 项目"></a>快速搭建基于 Servlet 3 的 Web 项目</h2><h3 id="一、让-Maven-支持-Web-环境"><a href="#一、让-Maven-支持-Web-环境" class="headerlink" title="一、让 Maven 支持 Web 环境"></a>一、让 Maven 支持 Web 环境</h3><p>在 pom.xml 中添加插件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作用1：导出war包，通过mvn war:war --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 作用2：导出可直接部署的项目，通过mvn war:exploded --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 插件式Tomcat --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Tomcat有3中形式存在：二进制、插件、内嵌API --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果需要命令行执行操作（mvn）需要添加以下插件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 否则会用默认或IDE的JDK版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>将 Maven 项目的打包方式改为 war</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加 Servlet 依赖支持</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet 3.1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="二、构建一个基于-Spring-父子容器的-Web-项目"><a href="#二、构建一个基于-Spring-父子容器的-Web-项目" class="headerlink" title="二、构建一个基于 Spring 父子容器的 Web 项目"></a>二、构建一个基于 Spring 父子容器的 Web 项目</h3><p>在 resources&#x2F;META-INF&#x2F;services 中添加一个名为 <code>javax.servlet.ServletContainerInitializer</code> 的文件，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.td.WebServletContainerInitializer</span><br></pre></td></tr></table></figure>

<p>WebServletContainerInitializer 如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定Web容器启动时需要处理的接口</span></span><br><span class="line"><span class="comment">// WebApplicationInitializer是Spring用于在Web环境下进行容器配置的接口</span></span><br><span class="line"><span class="comment">// 注意：如果使用了Spring-Web则可以不配置@HandlesTypes，因为这件事它帮我们做了</span></span><br><span class="line"><span class="meta">@HandlesTypes(WebApplicationInitializer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 容器启动时需要做的配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自定义的 WebApplicationInitializer </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVLET_MAPPING_PATH</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; RootContainerConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; WebContainerConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射路径</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123; SERVLET_MAPPING_PATH &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>AbstractAnnotationConfigDispatcherServletInitializer 实现了 WebApplicationInitializer 接口</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/001.png"></p>
</li>
</ul>
<p>父容器配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">        basePackages = &quot;com.td&quot;, // 组件所在位置</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class)</span></span><br><span class="line"><span class="meta">)</span> <span class="comment">// 扫描除了@Controller之外的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RootContainerConfig</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 入容器 Bean 配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子容器配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">        basePackages = &quot;com.td.controller&quot;, // 组件所在位置</span></span><br><span class="line"><span class="meta">        includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class),</span></span><br><span class="line"><span class="meta">        useDefaultFilters = false // 不对除了@Controller之外组件进行扫描</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebContainerConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 子容器 Bean 配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、测试是否搭建成功"><a href="#三、测试是否搭建成功" class="headerlink" title="三、测试是否搭建成功"></a>三、测试是否搭建成功</h3><p>在子容器的组件扫描范围（com.td.controller 包）下创建一个用于测试的 TestController </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Maven 的 tomcat7-maven-plugin 插件启动项目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn tomcat7:run</span><br></pre></td></tr></table></figure>

<p>使用 curl 工具测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin&gt;curl localhost:8080</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<p>可以看到至此一个基于 Servlet 3 和 Spring 父子容器的 Web 项目已经构建成功了。<br>父子容器的区别在于父容器在应用中是单一的，可以被多个（DispatcherServlet）子容器共享。</p>
<p>note：如果需要支持 JSP 则需要将当前 Maven 在 IDEA 中转为 Web 项目，将 JSP 视图存放到 webapp 目录下</p>
<h2 id="Spring-MVC-分派器原理"><a href="#Spring-MVC-分派器原理" class="headerlink" title="Spring MVC 分派器原理"></a>Spring MVC 分派器原理</h2><h3 id="父子容器是如何组装的？"><a href="#父子容器是如何组装的？" class="headerlink" title="父子容器是如何组装的？"></a>父子容器是如何组装的？</h3><p>在上面我们通过继承 AbstractAnnotationConfigDispatcherServletInitializer 抽象类成功配置了父子容器。所以我们可以进入其源码了解一下它是如何配置容器的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span></span><br><span class="line">		<span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建父容器</span></span><br><span class="line">    <span class="comment">// 用于创建ContextLoaderListener监听器</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">		Class&lt;?&gt;[] configClasses = getRootConfigClasses();</span><br><span class="line">        <span class="comment">// 如果提供了父容器的配置类，则创建父容器</span></span><br><span class="line">		<span class="keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;</span><br><span class="line">			<span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();  <span class="comment">// 使用注解配置的web上下文</span></span><br><span class="line">			context.register(configClasses); </span><br><span class="line">			<span class="keyword">return</span> context;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建子容器</span></span><br><span class="line">    <span class="comment">// 提供给DispatchServlet使用</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1）使用注解配置的web上下文</span></span><br><span class="line">		<span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">		Class&lt;?&gt;[] configClasses = getServletConfigClasses();</span><br><span class="line">        <span class="comment">// 2）如果提供了子容器的配置类，则注册到上下文中</span></span><br><span class="line">		<span class="keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;</span><br><span class="line">			context.register(configClasses);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 父子容器模板方法</span></span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt;[] getRootConfigClasses();</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt;[] getServletConfigClasses();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出 AbstractAnnotationConfigDispatcherServletInitializer 抽象类其实只是一个模板，用于创建父子容器对应的 WebApplicationContext。</p>
<p>当 DispatchServlet 被创建时，子容器的 WebApplicationContext 就会被传入以协助 init() 的初始化工作，而父容器则是在初始化 DispatchServlet 时被注入到子容器中（Servlet的init方法由Tomcat的生命周期操作回调）</p>
<p>DispatchServlet#init</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatchServlet#initServletBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化容器</span></span><br><span class="line">        <span class="built_in">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        <span class="comment">// 初始化分派Servlet</span></span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatchServlet#initWebApplicationContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从ServletContext中提取出父容器</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前DispatchServelt所在的子容器（在创建时被传入）</span></span><br><span class="line">        wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 注入父容器</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分派器剖析"><a href="#分派器剖析" class="headerlink" title="分派器剖析"></a>分派器剖析</h3><h4 id="回顾-Servlet-规范"><a href="#回顾-Servlet-规范" class="headerlink" title="回顾 Servlet 规范"></a>回顾 Servlet 规范</h4><p>我们知道 DispatchServlet 的本质就是 Servlet，所以在这先简单回顾一下 Servlet 标准</p>
<p>Servlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">    <span class="comment">// 获取当前Servlet的配置</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 请求处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span>;</span><br><span class="line">    <span class="comment">// 获取当前Servlet信息</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServletConfig</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServletConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 当前Servlet的名字</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletName</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// 当前Servlet的上限文对象</span></span><br><span class="line">    <span class="comment">// ServletContext是Servlet的三大域之一，除此之外还有request、session</span></span><br><span class="line">    <span class="keyword">public</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// 获取指定的初始化参数值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>;</span><br><span class="line">	<span class="comment">// 获取所有初始化参数值</span></span><br><span class="line">    <span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但一般我们很少直接使用 Servlet 接口，因为需要实现所有的抽象方法，所以后来就有了 GenericServlet 抽象类。GenericServlet 只是简单复写了 Servlet 接口，让其子类无需实现自己不需要的方法，即所谓的<strong>接口隔离原则</strong>。而除了 GenericServlet 之外，Servlet API 包还提供了 HttpServlet 抽象类（继承了GenericServlet），在 HttpServlet 中它将原来的 service 方法细分成了以下这几种操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">METHOD_DELETE</span> <span class="operator">=</span> <span class="string">&quot;DELETE&quot;</span>; <span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">METHOD_HEAD</span> <span class="operator">=</span> <span class="string">&quot;HEAD&quot;</span>; <span class="comment">// 紧获取响应头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">METHOD_GET</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>; <span class="comment">// 获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">METHOD_OPTIONS</span> <span class="operator">=</span> <span class="string">&quot;OPTIONS&quot;</span>; <span class="comment">// 查看通信状态（如果CORS的预检请求操作就会用到）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">METHOD_POST</span> <span class="operator">=</span> <span class="string">&quot;POST&quot;</span>; <span class="comment">// 新增</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">METHOD_PUT</span> <span class="operator">=</span> <span class="string">&quot;PUT&quot;</span>; <span class="comment">// 修改（幂等，即需要传输整个实体）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">METHOD_TRACE</span> <span class="operator">=</span> <span class="string">&quot;TRACE&quot;</span>; <span class="comment">// 检测请求，用于检测请求路线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求头，服务器对对比If-Modified-Since和本地的Last-Modified。如果Last-Modified比较大，这表示资源已修改，Servlet处理请求</span></span><br><span class="line"><span class="comment">// 而如果Last-Modified比较小，这表示资源没有变，返回304，即然浏览器使用缓存即可</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HEADER_IFMODSINCE</span> <span class="operator">=</span> <span class="string">&quot;If-Modified-Since&quot;</span>; </span><br><span class="line"><span class="comment">// 响应头，告诉浏览器当前请求的资源最后一次被修改的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HEADER_LASTMOD</span> <span class="operator">=</span> <span class="string">&quot;Last-Modified&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>而且 HttpServlet 的细分操作也很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">          res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 先将原来的request、response转为HTTP实现</span></span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 进行细分操作</span></span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为Servlet#service方法的重载，用于完成细分操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123; <span class="comment">// 不支持 If-Modified-Since，直接响应最新数据</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123; <span class="comment">// 请求的资源被修改过，响应最新数据</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 请求的资源没被修改过，无需放回，即让浏览器使用缓存</span></span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="comment">// 请求资源在服务器中最后一次被修改的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        <span class="comment">// 无法处理返回错误信息</span></span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Spring-MVC是如何接入-Servlet-规范的？"><a href="#Spring-MVC是如何接入-Servlet-规范的？" class="headerlink" title="Spring MVC是如何接入 Servlet 规范的？"></a>Spring MVC是如何接入 Servlet 规范的？</h4><p>关于 Spring MVC 我们接触得最多的 Servlet 肯定就是 DispatchServelt 了，所以我们可以先从它入手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>可以看到它继承了一个叫 FrameworkServlet 的父类，而该类的初始化动作我们在上面的 DispatchServlet#initServletBean 已经看到过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FrameworkServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServletBean</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>而 FrameworkServlet 又继承了 HttpServletBean（Spring Web模块提供的类），如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HttpServletBean</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentCapable</span>, EnvironmentAware &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>至此可以看到，Spring MVC 和 Servlet 的接入点就在 HttpServletBean 这个抽象类中，所以我们大可先看看它有没有复写其父类的方法</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/002.png"></p>
<p>可以看到它并没有复写诸如 service、doXXX 这些方法，只是添加了一些获取环境变量的操作而已，所以这时我们可以回看它的实现类 FrameworkServlet （它只一个直属实现）</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/003.png"></p>
<p>而在 FrameworkServlet 中我们发现，它实现了 serivce 方法，这时我们可以断定这就是关键所在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1)解析出请求方式</span></span><br><span class="line">    <span class="type">HttpMethod</span> <span class="variable">httpMethod</span> <span class="operator">=</span> HttpMethod.resolve(request.getMethod());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况1: 如果是PATCH请求（相当于PUT，但PATCH是非幂等的，即它提供的不是完整的资源）或没有解析到</span></span><br><span class="line">    <span class="comment">// 则对该请求进行再次封装和分配处理。这是因为 Servlet 规范并不支持 PATCH 请求，所以才需要扩展原来 HttpServlet#service 方法，这点需要注意</span></span><br><span class="line">    <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况2: 其他请求方式交给父类处理</span></span><br><span class="line">        <span class="comment">// 我们在上面已经了解到，当前 FrameworkServlet 的父类其实是 HttpServletBean</span></span><br><span class="line">        <span class="comment">// 但 HttpServletBean 并没有实现 service 方法，因此这里的 service 其实最后指的是 HttpServlet#service</span></span><br><span class="line">        <span class="comment">// 而 HttpServlet#serivce 只作分发工作（按HTTP请求方法）</span></span><br><span class="line">        <span class="built_in">super</span>.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以再看看 FrameworkServlet 是否有 doXXX 方法实现</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/004.png"></p>
<p>也就是说，当请求使用 HttpServlet#serivce 分发时，就会分发到 FrameworkServlet#doXXX 中处理。现在继续看看它都做了些什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">	processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">	processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">	processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他方法一样...</span></span><br></pre></td></tr></table></figure>

<p>可以看到它实现的 doXXX 其实并没有直接处理，而是将请求交给了 processRequest。该方法在上面也遇到过，处理 PATCH 请求的就是它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processRequest 也没有处理，又交给了 doService。注意，这里的 doService 其实是一个抽象方法，它的实现位于 DispatchServlet。 如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存request域的属性快照</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前环境的相关引用保存到request域</span></span><br><span class="line">    <span class="comment">// 1. 应用上下文容器</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    <span class="comment">// 2. 本地解析器（国际化相关）</span></span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">    <span class="comment">// 3. 主题解析器（支持页面主题样式，需要配合spring提供的taglib）</span></span><br><span class="line">    <span class="comment">// &lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;</span></span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将请求分派下去处理</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 在Servlet3开始，Servlet支持异步请求处理</span></span><br><span class="line">        <span class="comment">// request.getAsyncContext().start(Runnable)</span></span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="literal">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatchServlet#doDispatch（分派器的核心逻辑）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="comment">// 在HandlerExecutionChain中包含了“处理器”和“拦截器链”</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从处理器返回的ModelAndView（数据和视图信息）</span></span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是不是文件上传操作（譬如表单的enctype=&quot;multipart/form-data&quot;）</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一、通过映射器（HandlerMapping）匹配并返回具体的处理器实现和拦截器链</span></span><br><span class="line">            <span class="comment">// 以Spring 5.3.1为例有以下3个内置的处理器映射器</span></span><br><span class="line">            <span class="comment">// 1. BeanNameUrlHandlerMapping: 让url和bean名字进行映射匹配，常用于Controller接口实现方式的处理器定义</span></span><br><span class="line">            <span class="comment">// 2. RequestMappingHandlerMapping：让url和@RequestMapping进行映射匹配（包含其余的Restful风格注解，其实本质只是@RequestMapping的派生注解）</span></span><br><span class="line">            <span class="comment">// 3. RouterFunctionMapping：让url和RouterFunction映射（Spring5.2新特性，用于简化Controller编写）</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二、根据处理器返回对应的适配器</span></span><br><span class="line">            <span class="comment">// 以Spring 5.3.1为例有以下4个内置的处理器适配器</span></span><br><span class="line">            <span class="comment">// 1. HandlerFunctionAdapter：处理器通过RouterFunctions实现</span></span><br><span class="line">            <span class="comment">// 2. HttpRequestHandlerAdapter：处理器通过@RequestMapping实现</span></span><br><span class="line">            <span class="comment">// 3. SimpleControllerHandlerAdapter：处理器通过Controller接口实现</span></span><br><span class="line">            <span class="comment">// 4. SimpleServletHandlerAdapter：处理器通过Servlet接口实现</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否有必要真的执行</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 三、执行拦截器链的preHandle方法</span></span><br><span class="line">            <span class="comment">// 这时可以对HttpServletRequest和HttpServletResponse修改</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 四、通过适配器执行处理器</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 如果没有指定视图名称则返回默认的</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 五、执行拦截器链postHandle方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 六、执行响应操作</span></span><br><span class="line">        <span class="comment">// 1. 根据视图解析器解析出视图View，然后对数据进行渲染</span></span><br><span class="line">        <span class="comment">// 2. 执行拦截器链afterCompletion</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;   </span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流程图</p>
</blockquote>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/005.png"></p>
<ul>
<li>对于@RequestMapping处理而言，请求的参数和响应数据的处理可参考 RequestMappingHandlerAdapter 适配器</li>
</ul>
<h3 id="装配过程"><a href="#装配过程" class="headerlink" title="装配过程"></a>装配过程</h3><ol>
<li>WebApplicationContext 上下文容器启动</li>
<li>实例化 Singleton 域的 Bean，其顺序规则大致如下：<ol>
<li>先实例化配置类</li>
<li>定义在配置类上的注解，譬如@EnableWebMvc、@Import之类</li>
<li>按照配置类的定义从上到下（次过程也会按需实例化，即实例化A时发现依赖了B，这先实例化B，如此类推。）</li>
</ol>
</li>
<li>因为 WebContainerConfig 被 @EnableWebMvc 标注，所以在 WebContainerConfig 实例化后会马上实例化DelegatingWebMvcConfiguration</li>
<li>继续回到 WebContainerConfig，按定义顺序和需要继续实例化 Bean</li>
<li>如果 WebContainerConfig 复写了 WebMvcConfigurer 的方法，则必要时就会实例化 WebMvcConfigurationSupport 中对应的Bean，因为它是 DelegatingWebMvcConfiguration 的父类。除此之外还会触发 DelegatingWebMvcConfiguration 的委派操作，这时如果环境中有多个 WebMvcConfigurer 实现，则只要其中一个 WebMvcConfigurer 的方法被执行，其他所有 WebMvcConfigurer 对应的方法都会被执行。</li>
</ol>
<h3 id="请求数据是如何流入处理器的？"><a href="#请求数据是如何流入处理器的？" class="headerlink" title="请求数据是如何流入处理器的？"></a>请求数据是如何流入处理器的？</h3><blockquote>
<p>基本流程</p>
</blockquote>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/006.png"></p>
<blockquote>
<p>普通解析器（默认），用于解析 HttpServletRequest中的内容</p>
</blockquote>
<p>以 RequestMappingHandlerAdapter#getDefaultArgumentResolvers 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title function_">getDefaultArgumentResolvers</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持@RequestParam和MultipartFile解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="literal">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMapMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持@PathVariable解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">PathVariableMapMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持@MatrixVariable解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MatrixVariableMethodArgumentResolver</span>());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MatrixVariableMapMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持@ModelAttribute解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 支持@RequestBody和@ResponseBody解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    <span class="comment">// 支持@RequestPart解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestPartMethodArgumentResolver</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    <span class="comment">// 支持@RequestHeader解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestHeaderMapMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持@CookieValue解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    <span class="comment">// 支持@Value解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    <span class="comment">// 支持@SessionAttribute解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">SessionAttributeMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持@RequestAttribute解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestAttributeMethodArgumentResolver</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type-based argument resolution</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持以下类型的解析（即可以直接写在处理器参数列表上，Spring MVC会自动将内容注入到其中）</span></span><br><span class="line">    <span class="comment">// WebRequest、ServletRequest、MultipartRequest、HttpSession</span></span><br><span class="line">	<span class="comment">// Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 ServletResponse、OutputStream、Writer 解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletResponseMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 HttpEntity、RequestEntity 解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">HttpEntityMethodProcessor</span>(getMessageConverters(), <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    <span class="comment">// 支持 RedirectAttributes 解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RedirectAttributesMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 Model 解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ModelMethodProcessor</span>());</span><br><span class="line">    <span class="comment">// 支持 Map 解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">MapMethodProcessor</span>());</span><br><span class="line">    <span class="comment">// 支持 Errors 解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ErrorsMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 SessionStatus 解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">SessionStatusMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 UriComponentsBuilder 解析</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">UriComponentsBuilderMethodArgumentResolver</span>());</span><br><span class="line">    <span class="keyword">if</span> (KotlinDetector.isKotlinPresent()) &#123;</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> <span class="title class_">ContinuationHandlerMethodArgumentResolver</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义解析器</span></span><br><span class="line">    <span class="comment">// 在 WebMvcConfigurationSupport#requestMappingHandlerAdapter 中调用</span></span><br><span class="line">    <span class="comment">// 添加操作可通过实现WebMvcConfigurer接口的addArgumentResolvers方法实现</span></span><br><span class="line">    <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="literal">null</span>) &#123;</span><br><span class="line">        resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Catch-all</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="literal">true</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>简单说就是 Spring MVC 支持直接在方法参数列表中定义以上类型的注解或参数，然后它会自动将 HttpServletRequest 中的内容提取出来再封装进去</li>
</ul>
<blockquote>
<p>绑定参数解析器（即显式指定了绑定对象，如 @PathVariable(“date”) LocalDateTime date），通样用于解析 HttpServletRequest中的内容</p>
</blockquote>
<p>以 RequestMappingHandlerAdapter#getDefaultInitBinderArgumentResolvers 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title function_">getDefaultInitBinderArgumentResolvers</span><span class="params">()</span> &#123;</span><br><span class="line">	List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">    <span class="comment">// 支持 @RequestParam(name=xxx) 绑定解析</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="literal">false</span>));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMapMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 @PathVariable(value=xxx) 绑定解析</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">PathVariableMapMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 @MatrixVariable(name=xxx) 绑定解析</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">MatrixVariableMethodArgumentResolver</span>());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">MatrixVariableMapMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 @Value 绑定解析</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(getBeanFactory()));</span><br><span class="line">    <span class="comment">// 支持 @SessionAttribute 绑定解析</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">SessionAttributMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 @RequestAttribute 绑定解析</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestAttributeMethodArgumentResolver</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Type-based argument resolution</span></span><br><span class="line">    <span class="comment">// 支持一下类型绑定解析</span></span><br><span class="line">    <span class="comment">// WebRequest、ServletRequest、MultipartRequest、HttpSession</span></span><br><span class="line">	<span class="comment">// Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>());</span><br><span class="line">    <span class="comment">// 支持 ServletResponse、OutputStream、Writer 绑定解析</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">ServletResponseMethodArgumentResolver</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义解析器</span></span><br><span class="line">    <span class="comment">// 在 WebMvcConfigurationSupport#requestMappingHandlerAdapter 中调用</span></span><br><span class="line">    <span class="comment">// 添加操作可通过实现WebMvcConfigurer接口的addArgumentResolvers方法实现</span></span><br><span class="line">	<span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="literal">null</span>) &#123;</span><br><span class="line">		resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Catch-all</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">PrincipalMethodArgumentResolver</span>());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>返回值处理器</p>
</blockquote>
<p>以 RequestMappingHandlerAdapter#getDefaultReturnValueHandlers 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; <span class="title function_">getDefaultReturnValueHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">	List&lt;HandlerMethodReturnValueHandler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Single-purpose return value types</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持 ModelAndView 返回类型处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">ModelAndViewMethodReturnValueHandler</span>());</span><br><span class="line">    <span class="comment">// 支持 Model 返回类型处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">ModelMethodProcessor</span>());</span><br><span class="line">    <span class="comment">// 支持 View 返回类型处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">ViewMehodReturnValueHandler</span>());</span><br><span class="line">    <span class="comment">// 支持 ResponseEntity 返回类型处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">ResponseBodyEmitterReturnValueHandler</span>(getMessageConverters(),</span><br><span class="line">			<span class="built_in">this</span>.reactiveAdapterRegistry, <span class="built_in">this</span>.taskExecutor, <span class="built_in">this</span>.contentNegotiationManager));</span><br><span class="line">    <span class="comment">// 支持 StreamingResponseBody 返回类型处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">StreamingResponseBodyReturnValueHandler</span>());</span><br><span class="line">    <span class="comment">// 支持 HttpEntity 返回值处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">HttpEntityMethodProcessor</span>(getMessageConverters(),</span><br><span class="line">			<span class="built_in">this</span>.contentNegotiationManager, <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    <span class="comment">// 支持 HttpHeaders 返回值处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">HttpHeadersReturnValueHandler</span>());</span><br><span class="line">    <span class="comment">// 支持 Callable 返回值处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">CallableMethodReturnValueHandler</span>());</span><br><span class="line">    <span class="comment">// 支持 DeferredResult、ListenableFuture、CompletionStage 返回值处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">DeferredResultMethodReturnValueHandler</span>());</span><br><span class="line">    <span class="comment">// 支持 WebAsyncTask 返回值处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">AsyncTaskMethodReturnValueHandler</span>(<span class="built_in">this</span>.beanFactory));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Annotation-based return value types</span></span><br><span class="line">    <span class="comment">// 支持 @ModelAttribute</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 支持 @ResponseBody</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(),</span><br><span class="line">			<span class="built_in">this</span>.contentNegotiationManager, <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Multi-purpose return value types</span></span><br><span class="line">    <span class="comment">// 支持 void、CharSequence “视图名”返回值处理</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">ViewNameMethodReturnValueHandler</span>());</span><br><span class="line">    <span class="comment">// 支持 Map 返回值处理（没有用注解）</span></span><br><span class="line">	handlers.add(<span class="keyword">new</span> <span class="title class_">MapMethodProcessor</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义返回值处理器</span></span><br><span class="line">    <span class="comment">// 在 WebMvcConfigurationSupport#getReturnValueHandlers 中调用</span></span><br><span class="line">    <span class="comment">// 添加操作可通过实现WebMvcConfigurer接口的addReturnValueHandlers方法实现</span></span><br><span class="line">	<span class="keyword">if</span> (getCustomReturnValueHandlers() != <span class="literal">null</span>) &#123;</span><br><span class="line">		handlers.addAll(getCustomReturnValueHandlers());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Catch-all</span></span><br><span class="line">	<span class="keyword">if</span> (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123;</span><br><span class="line">		handlers.add(<span class="keyword">new</span> <span class="title class_">ModelAndViewResolverMethodReturnValueHandler</span>(getModelAndViewResolvers()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		handlers.add(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> handlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流程案例：以处理返回 Json 数据为例子</p>
</blockquote>
<p>首先需要将负责处理 Json 数据的转换器（HttpMessageConverter）添加到环境中</p>
<p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title function_">mappingJackson2HttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    objectMapper.setDateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">mappingJackson2HttpMessageConverter</span></span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(objectMapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mappingJackson2HttpMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123; <span class="comment">// 接收的是Json</span></span><br><span class="line">    System.out.println(person);</span><br><span class="line">    person.setName(<span class="string">&quot;server ：&quot;</span> + person.getName());</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &#x27;&#123;&quot;name&quot;:&quot;sam&quot;,&quot;age&quot;:&quot;18&quot;&#125;&#x27; -H &#x27;Content-Type:application/json&#x27; -X POST localhost:8080/add</span><br></pre></td></tr></table></figure>

<p>过程</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/007.png"></p>
<p>从上图中可以发现，先是从 HandlerMethodArgumentResolver 中查找出支持解析当前处理器参数列表上对应类型的解析器（这里是RequestResponseBodyMethodProcessor），然后再通过 HttpMessageConverter 进行请求转换（从json串转为对象）后将结果传给处理器，最后反射执行处理器处理请求（参数是getBean（即处理器所在的Bean）和处理好的参数）</p>
<h3 id="常用-WebMvcConfigurer-配置"><a href="#常用-WebMvcConfigurer-配置" class="headerlink" title="常用 WebMvcConfigurer 配置"></a>常用 WebMvcConfigurer 配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊的处理器映射器：快速映射到视图</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">    registry.addViewController(<span class="string">&quot;/about&quot;</span>).setViewName(<span class="string">&quot;about&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊的处理器映射器：静态资源映射</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/res/**&quot;</span>).addResourceLocations(<span class="string">&quot;/static/**&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义转换器，只针对处理器参数类表</span></span><br><span class="line"><span class="comment">// Formatter类型转换器，String -&gt; T</span></span><br><span class="line"><span class="comment">// Converter类型转换器，S -&gt; T</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// registry.addFormatter(null);</span></span><br><span class="line">    <span class="comment">// registry.addConverter(null);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义处理器的异常解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">    <span class="comment">// resolvers.add(null);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图模板位置解析</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">    registry.jsp(<span class="string">&quot;/views/&quot;</span>, <span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CORS跨域支持</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">  registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;*&quot;</span>).allowedMethods(<span class="string">&quot;*&quot;</span>).allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Listener、Filter、Interceptor、AOP-的作用和区别"><a href="#Listener、Filter、Interceptor、AOP-的作用和区别" class="headerlink" title="Listener、Filter、Interceptor、AOP 的作用和区别"></a>Listener、Filter、Interceptor、AOP 的作用和区别</h2><h3 id="使用-Tomcat-Embed-运行项目"><a href="#使用-Tomcat-Embed-运行项目" class="headerlink" title="使用 Tomcat-Embed 运行项目"></a>使用 Tomcat-Embed 运行项目</h3><blockquote>
<p>说明</p>
</blockquote>
<p>因为 Listener 和 Filter 是由 Web 容器来负责触发的，而又因为 Maven 插件方式的部署无法跟踪其代码执行流程，所以为了方便起见我们可以干脆将 Tomcat 切换为由 API 控制，即内嵌版 Tomcat。</p>
<blockquote>
<p>配置</p>
</blockquote>
<p>添加依赖和资源配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 不能和 Maven Tomcat 插件同时使用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果要用插件则应该设置 &lt;scope&gt;provided&lt;/scope&gt;  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不进行传播和打包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配合tomcat-embed使用，编译时将views拷贝到classes --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 因为编译不会像打包那样将全部需要的资源拷贝的输出中 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将webapp/views拷贝到target/classes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 拷贝到target/classes/META-INF --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/META-INF<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建 Tomcat 的启动类，并让其加载当前案例项目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatStarter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTEXT_PATH;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_WEB_CLASSES_PATH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        DEFAULT_CONTEXT_PATH = <span class="string">&quot;/&quot;</span>; <span class="comment">// 访问路径</span></span><br><span class="line">        DEFAULT_WEB_CLASSES_PATH = Paths.get(<span class="string">&quot;target/classes&quot;</span>).toAbsolutePath().toString(); <span class="comment">// 可执行项目所在路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line"></span><br><span class="line">        tomcat.addWebapp(DEFAULT_CONTEXT_PATH, DEFAULT_WEB_CLASSES_PATH);</span><br><span class="line"></span><br><span class="line">        tomcat.setPort(<span class="number">8888</span>);</span><br><span class="line">        tomcat.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动连接器，处理HTTP请求</span></span><br><span class="line">        tomcat.getConnector().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><blockquote>
<p>基本介绍</p>
</blockquote>
<p>观察者是一种用于构建<code>一对多关系模型</code>的行为型设计模式，作用是当“一”方发生状态改变时，“多”方就会感知到并自动执行处理逻辑，所以 Listener 的主要作用其实是为了监听某些特定对象，而这些对象常见有如下这些：</p>
<ul>
<li>ServletContextListener：监听 ServletContext 的初始化和销毁事件</li>
<li>ServletContextAttributeListener：监听 ServletContext 属性的更新事件（包含增删改）</li>
<li>ServletRequestListener：监听 ServletRequestListener 的初始化和销毁事件</li>
<li>ServletRequestAttributeListener：监听 ServletRequestAttributeListener 属性的更新事件（包含增删改）</li>
<li>ReadListener：监听输入流状态事件（已读、异常、可能在读 javax.servlet.ServletInputStream#isReady() 被调用时）</li>
<li>WriteListener：监听输出流状态事件（可能在写，在 javax.servlet.ServletOutputStream#isReady() 被调用时）</li>
</ul>
<blockquote>
<p>执行时机</p>
</blockquote>
<p>案例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 容器启动时需要做的配置</span></span><br><span class="line"></span><br><span class="line">        ctx.addListener(<span class="keyword">new</span> <span class="title class_">ServletContextListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ServletContext被初始化&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ctx.addListener(<span class="keyword">new</span> <span class="title class_">ServletRequestListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ServletRequest被初始化&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面我们注册了两个监听器，分别是 ServletContextListener 和 ServletRequestListener</li>
<li>然后我们可以在其初始化方法实现中各自打一个断点进行观察</li>
</ul>
<p>启动 Tomcat </p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/008.png"></p>
<p>接着放行端点，但放行后发现并没有执行 Request 监听器，这里不难理解，因为这时还没有用户请求所以肯定不会生成 Request 和 Response 实例。</p>
<p>现在模拟请求触发断点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:8888</span><br></pre></td></tr></table></figure>

<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/009.png"></p>
<p>到这里我们就得到了以下信息：</p>
<ul>
<li>ServletContextListener 优先级别最高，在容器启动时执行</li>
<li>Request 和 Response 实例在请求到来时生成</li>
<li>Request 和 Response 会流经管道后转变成符合 Servlet 规范处理要求的 ServletRequest 和 ServletResponse</li>
</ul>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><blockquote>
<p>基本介绍</p>
</blockquote>
<p>过滤器顾名思义就是用来筛选信息的，开发者可以通过实现 Filter 来对 Request、Response 进行处理。过滤器通常不会单个存在，所以它时常会伴随着<code>责任链模式</code>出现。即多个过滤器按顺序形成一条过滤链，而每个过滤器都有各自的责任，所以这条链就叫责任链。责任链模式非常常见，除了当前 Filter 外，上面提到的<code>管道模式</code>其实也是一种责任链，除此之外后面将要聊到的 Interceptor、AOP 都用到了责任链。</p>
<blockquote>
<p>快速入门责任链模式</p>
</blockquote>
<p>Filter 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">    <span class="comment">// 执行拦截</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">                         FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到，在 doFilter 的参数列表中就有一个 FilterChain 类型的变量，而这个类就是责任链模式实现</li>
</ul>
<p>FilterChain 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line">    <span class="comment">// 执行拦截</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span> <span class="params">( ServletRequest request, ServletResponse response )</span> <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该接口看上去很简单，只有一个 doFilter 方法</li>
<li>注意，到这里我们发现了件有趣的事，不知道你有没有感觉 FilterChain#doFilter 方法看上去更加适合 Filter，所以我们在这可以发挥一下想象力，就是认为责任链模式的实现技巧就是将 Chain（“链”）添加到自己“原本”的方法中，而“原本”的方法就转移到 Chain（“链”） 中</li>
<li>在 Tomcat 中 FilterCain 的实现只有一个 ApplicationFilterChain</li>
</ul>
<p>以下为去除了多余操作的 ApplicationFilterChain 源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 过滤器器包装类（责任链）</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationFilterConfig[] filters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1、往责任链上添加Filter处理器</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;</span><br><span class="line">        <span class="comment">//...	</span></span><br><span class="line">        filters[n++] = filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 2、添加Servlet，用于执行完责任链后进行请求处理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setServlet</span><span class="params">(Servlet servlet)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servlet = servlet;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 从头执行责任链</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            internalDoFilter(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internalDoFilter</span><span class="params">(ServletRequest request,</span></span><br><span class="line"><span class="params">                                  ServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 执行责任链</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					</span><br><span class="line">										<span class="comment">// 执行Filter</span></span><br><span class="line">                    filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">/**/) &#123;</span></span><br><span class="line"><span class="comment">                //...</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                // 执行完责任链，开始执行Servlet（如果是Spring MVC，这个Servlet这为DispatchServlet）</span></span><br><span class="line"><span class="comment">                servlet.service(request, response);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException | ServletException | RuntimeException e) &#123;</span></span><br><span class="line"><span class="comment">            //...</span></span><br><span class="line"><span class="comment">        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">            //...</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 释放责任链</span></span><br><span class="line"><span class="comment">    void release() &#123;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">            filters[i] = null;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        n = 0;</span></span><br><span class="line"><span class="comment">        pos = 0;</span></span><br><span class="line"><span class="comment">        servlet = null;</span></span><br><span class="line"><span class="comment">        servletSupportsAsync = false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void reuse() &#123;</span></span><br><span class="line"><span class="comment">        pos = 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>责任链的执行过程如下</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/010.png"></p>
<blockquote>
<p>执行时机</p>
</blockquote>
<p> 案例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 容器启动时需要做的配置</span></span><br><span class="line"></span><br><span class="line">        ctx.addFilter(<span class="string">&quot;my-filter&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpFilter</span>()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行过滤器：&quot;</span> + <span class="built_in">this</span>.getFilterName());</span><br><span class="line"></span><br><span class="line">                chain.doFilter(request, response);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).addMappingForUrlPatterns(<span class="literal">null</span>, <span class="literal">false</span>, <span class="string">&quot;/*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ctx.addListener(<span class="keyword">new</span> <span class="title class_">ServletRequestListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ServletRequest被初始化&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 Tomcat，并模拟请求触发断点</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/011.png"></p>
<h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><blockquote>
<p>基本介绍</p>
</blockquote>
<p>在 Spring Web 模块中提供了两种类型的拦截器，分别是 HandlerInterceptor、WebRequestInterceptor。在处理器被执行前后 Spring 会对其进行适配调用，而两者的区别是 WebRequestInterceptor 只能获取WebRequest 、ModelMap 进行修改而不能阻断请求，而 HandlerInterceptor 更强大，更像 Filter。</p>
<p>注意，如果需要实现拦截器，则可以通过直接继承 HandlerInterceptorAdapter 而不是实现 HandlerInterceptor，因为这样可以省略不必要的实现（接口隔离原则）。</p>
<p>题外话，不难发好些地方都是通过抽象类来简单对接口的实现，从而做到接口隔离原则，但在JDK1.8后，Java添加了接口的新特性“默认方法”，即以后无需再多写一个抽象来实现接口以求达到接口隔离，而只需要使用默认方法提供默认实现，这样之类就可以不用实现自己不需要的接口了。</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/012.png"></p>
<blockquote>
<p>拦截器责任链</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; interceptorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">interceptorIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size(); i++) &#123;</span><br><span class="line">			<span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">			<span class="comment">// 将 request, response, handler 让所有拦截器进行“预”处理（譬如预统一处理或阻截操作）</span></span><br><span class="line">			<span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">				triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">			<span class="comment">// 将 request, response, handler 让所有拦截器进行“后”处理（譬如结果统一处理）</span></span><br><span class="line">			interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Exception ex)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">			<span class="comment">// 将 request, response, handler 让所有拦截器进行“渲染后”处理（譬如释放资源、记录处理后日志）</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex2) &#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，拦截器责任链和上面过滤器责任链的不同之处是，过滤器针对的是Servlet，而拦截器针对的是Handler，但两者都可以对 Request 和 Response 进行过滤处理。除此之外，两者有个比较大的区别，就是拦截器责任链执行到某个拦截器时，该拦截器可以选择不继续执行后续的拦截器而直接执行处理器。也就是说，再拦截器责任链中，拦截器链的传递是由拦截器本身控制的，这点和过滤器链不同。</p>
<blockquote>
<p>执行时机</p>
</blockquote>
<p>DispatcherServlet#doDispatch</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/013.png"></p>
<h3 id="AOP（-Aspect-Oriented-Programming-）"><a href="#AOP（-Aspect-Oriented-Programming-）" class="headerlink" title="AOP（ Aspect Oriented Programming ）"></a>AOP（ Aspect Oriented Programming ）</h3><blockquote>
<p>AOP 术语</p>
</blockquote>
<ul>
<li>关注点代码<ul>
<li>在多个方法中出现的代码</li>
</ul>
</li>
<li>通知（Advice&#x2F;Interceptor）<ul>
<li>可以简单理解为使关注点代码在AOP处理中的基本单位</li>
</ul>
</li>
<li>切入点<ul>
<li>需要织入关注点代码（通知）的方法</li>
<li>在Spring AOP中，切入点单位只能是方法</li>
</ul>
</li>
<li>切入点表达式<ul>
<li>定义切入点的表达式</li>
</ul>
</li>
<li>织入<ul>
<li>指将通知添加到切入点的这个过程</li>
</ul>
</li>
</ul>
<blockquote>
<p>基本介绍</p>
</blockquote>
<p>AOP 是一种编程思想，它旨在将重复出现在多个方法中的代码抽离并单独存放，然后在需要时将其织入到方法中。它是一种降低代码耦合性和无侵入扩展的实现方案，而且 Spring AOP 的思想和前面提到的拦截器（Interceptor）很像，你可以简单理解只要是拦截器能做到的 AOP 都能够做到，而且能做得更好。</p>
<p>除此之外，你还可以使用 AOP 实现诸如<code>日志记录</code>、<code>权限管理</code>、<code>代码埋点提取信息（多见于通过agent在启动应用时附加在应用上）</code>、<code>性能监控</code>、<code>事务管理（Spring声明式事务）</code>、<code>配合EL表达式完成缓存管理</code>, <code>Spring MVC的异常处理（例如被@ControllerAdvice定义的类其实就是一个切面类）</code>等等。</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/014.png"></p>
<p>在 Java 中 AOP 织入时机可以分为以下这几种：</p>
<ul>
<li>编译时织入：AspectJ</li>
<li>类加载时织入：AspectJ 5</li>
<li>运行时织入：Spring AOP、Java Agent</li>
</ul>
<p>AOP 在 Spring 的常见应用案例：</p>
<ul>
<li>事务管理</li>
<li>缓存管理</li>
<li>统一异常处理</li>
</ul>
<p>Spring AOP 支持的几种配置方式：</p>
<ul>
<li>基于 ProxyFactoryBean</li>
<li>XML 的 AOP 标签（xmlns:aop&#x3D;”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/aop&quot;%EF%BC%89">http://www.springframework.org/schema/aop&quot;）</a></li>
<li>@Aspect 注解（推荐）</li>
</ul>
<blockquote>
<p>案例代码</p>
</blockquote>
<p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启用 AOP（@Aspect）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为当前案例的切入点是Controller，所以必须标注在管理Controller的子容器配置类上，否则不生效</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">        basePackages = &quot;com.td.controller&quot;,</span></span><br><span class="line"><span class="meta">        includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class),</span></span><br><span class="line"><span class="meta">        useDefaultFilters = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebContainerConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义切面类</p>
<ul>
<li>可以理解为是 <strong>Advice（Interceptor）</strong>和<strong>切入点配置</strong>的集合类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切入点表达式：表示拦截 TestController 中的所有(切入点)方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.td.controller.TestController.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAspect#before&quot;</span>);</span><br><span class="line">        System.out.println(joinPoint.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAspect#after&quot;</span>);</span><br><span class="line">        System.out.println(joinPoint.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAspect#around-pre&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAspect#around-post&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Servlet Filter</span><br><span class="line">HandlerInterceptor#preHandle</span><br><span class="line">MyAspect#around-pre</span><br><span class="line">MyAspect#before</span><br><span class="line">执行处理器</span><br><span class="line">MyAspect#after</span><br><span class="line">MyAspect#around-post</span><br><span class="line">HandlerInterceptor#postHandle</span><br><span class="line">HandlerInterceptor#afterCompletion</span><br></pre></td></tr></table></figure>

<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/015.png"></p>
<p>Advice 之所以在拦截器之后执行，是因为 Spring AOP 是通过代理来实现的。即如果 Spring 发现某个类被切入点表达式锁定，就会为其创建一个代理类，而织入操作就是在调用方法的时候，所以拦截器前置方法执行时根本还没执行处理器，而且从这点可以看出要使用 Spring AOP，那么其拦截目标必须被 Spring 容器所管理，否则不生效。<br>以下为 Advice 的执行顺序：</p>
<ul>
<li>相同类型 Advice ，按照定义顺序织入</li>
<li>不同类型：around -&gt; before -&gt; after</li>
</ul>
<blockquote>
<p>Spring AOP 原理以及执行时机</p>
</blockquote>
<p>虽然关于 Spring AOP 的原理已经在以前的文章中详细地聊过了，但为了当前文章更加饱满，以及践行温故而知新的理念，所以还是打算再次看看 Spring AOP 是执行原理。但在这之前需要多说一句，这部分内容的前置知识点是 Bean 的生命周期过程，所以应该要有先后次序地理解。</p>
<p>Spring 会在 Bean 生命周期的初始化阶段（initializeBean）回调 BeanPostProcessor，而在回调后置处理方法期间会通过一个叫 <code>AnnotationAwareAspectJAutoProxyCreator(主要用getAdvicesAndAdvisorsForBeanf方法)</code> 的 BeanPostProcessor 来判断当前 Bean 是否有必要生成代理，其判断的主要依据如下</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/016.png"></p>
<p>以上图 TestController 这个 Bean 为例，它的通知有以下这些</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/017.png"></p>
<p>这是因为先前我们定义了<strong>切入点表达式</strong>锁定了 TestController 的所有方法的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.td.controller.TestController.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因此，在 AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean 时就会通过切入点表达式返回匹配的通知。</p>
<p>但现在的问题是，Spring 是如何知道有哪些通知的？其过程大致如下：</p>
<ol>
<li>在 Spring 容器启动时，检测到配置类上有 @EnableAspectJAutoProxy 注解，因此就会在上下文中注册一个 AnnotationAwareAspectJAutoProxyCreator 的 BeanPostProcessor 用于判断每一个 Bean 是否有必要生成切面代理实例</li>
<li>经过步骤 1 之后，当有 Bean 触发 AnnotationAwareAspectJAutoProxyCreator 的后处理方法 postProcessBeforeInstantiation 回调时，就会判断哪些是切面类。具体逻辑位于 BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors 方法中</li>
<li>是否为切面类的判断步骤如下：<ol>
<li>先通过 BeanFactory 获取到所以 Bean 的 BeanName</li>
<li>循环地根据 BeanName 获取到与其对应的 Bean Type</li>
<li>最后通过 AspectJAdvisorFactory#isAspect 方法判断其类是否被 @Aspect 注解</li>
</ol>
</li>
<li>找出切面类之后，会通过 AspectJAdvisorFactory#getAdvisors 返回类中匹配的通知方法</li>
</ol>
<p>至此，所有的通知都被找了出来，它们会在<strong>判断是否需要为 Bean 生成切面代理实例</strong>或<strong>代理目标方法被执行</strong>时被应用。</p>
<p>当代理实例生成后，它会像其他 Bean 一样被添加到容器中以提供给使用者使用。</p>
<p>最后，我们可以在目标方法中打个断点观察其代理是如何执行方法的</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/018.png"></p>
<p>上图中 DynamicAdvisedInterceptor#intercept 的源码如下</p>
<p><img src="/SpringMVC%E5%86%8D%E5%85%A5%E9%97%A8/019.png"></p>
<p>总结：</p>
<ul>
<li>通知（Advice&#x2F;Interceptor）和目标方法会以责任链形式执行</li>
<li>之所以一直称通知为拦截器，是因为通知其实际是 Advice ，而在 AOP 中 Interceptor 就继承自 Advice 。而它比较常用的一个实现就是进行事务管理的<code>TransactionInterceptor</code>、<code>CacheInterceptor</code></li>
</ul>
<h2 id="拓展：Spring-MVC是如何处理异常的？"><a href="#拓展：Spring-MVC是如何处理异常的？" class="headerlink" title="拓展：Spring MVC是如何处理异常的？"></a>拓展：Spring MVC是如何处理异常的？</h2><ol>
<li><p>请求到来后，通过DispacherServlet映射器获取处理器时，会创建一个HandlerMethod（存放了目标方法、响应吗、参数、所在类、bean容器等信息）</p>
</li>
<li><p>然后通过HandlerMethod和request获取其拦截器链，最后通过将 HandlerMethod和拦截器链封装到HandlerExecutionChain返回</p>
</li>
<li><p>根据处理器类型获取适配器</p>
</li>
<li><p>执行拦截器前置拦截</p>
</li>
<li><p>适配调用handler（如果用的是@RequestMapping，适配器是RequestMappingHandlerAdapter）</p>
<ol>
<li><p>会将目标方法包装成ServletInvocableHandlerMethod（继承自InvocableHandlerMethod）扩展其能力（如支持@ResponseStatus）</p>
</li>
<li><p>将以下内容添加到ServletInvocableHandler</p>
<ul>
<li>参数解析器（this.argumentResolvers）</li>
<li>返回值处理器（this.returnValueHandlers）</li>
<li>参数名发现器（ParameterNameDiscoverer）</li>
</ul>
</li>
<li><p>调用ServletInvocableHandler#invokeAndHandle方法，执行请求处理：</p>
<ol>
<li><p>解析出参数</p>
</li>
<li><p>反射调用目标方法</p>
</li>
<li><p>【注意】假设目标出现了异常，这时会将异常往外抛出（抛到DispacherServlet）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">targetException</span> <span class="operator">=</span> ex.getTargetException();</span><br><span class="line"><span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">	<span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">	<span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">	<span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>因为处理器抛出了异常，所以 DispacherServlet 不会再执行拦截器，而是直接执行 processDispatchResult 处理请求的返回结果</p>
<ol>
<li><p>DispacherServlet#processDispatchResult提取出目标方法，接着交给 DispacherServlet#processHandlerException</p>
</li>
<li><p>DispacherServlet#processHandlerException 会将 request、response、handler、exception 等信息传递给 this.handlerExceptionResolvers 解析处理（默认有两个：DefaultErrorAttributes（用于解析出错误信息）、HandlerExceptionResolverComposite（组装了多个异常解析器，用于处理程序映射或执行期间抛出的异常））。其中在 HandlerExceptionResolverComposite 中默认有以下3个异常解析处理器（按顺序处理）：</p>
<ul>
<li>ExceptionHandlerExceptionResolver：利用@ExceptionHandler处理异常（如果有的话）</li>
<li>ResponseStatusExceptionResolver：解析@ResponseStatus信息</li>
<li>DefaultHandlerExceptionResolver：解析标准SpringMVC异常，并将它们转换为相应的HTTP状态代码（就是出现了<code>SpringMVC内置的特定异常</code>，设置特定状态码，如404、500、406等等等等）,但如果不是抛出Spring的异常，这不会被处理。</li>
</ul>
</li>
<li><p>【注意】如果没有使用@ExceptionHandler、@ResponseStatus、Spring内置的异常类的话，则DispacherServlet#processHandlerException是并不会处理该异常，它会将异常抛给自己的父类FrameworkServlet处理，但其实FrameworkServlet也不会处理，而是将其再次封装成NestedServletException继续往外抛，直到Tomcat发现这个异常，这时Tomcat会重定向到<code>/error页面（如果是SpringBoot，会自动配置）</code>，这时请求会再次被DispatcherServlet处理。<br>如果是SpringBoot的话，会自动添加一个<code>BasicErrorController</code>来处理<code>/error</code>的请求，BasicErrorController这个处理器是通过实现Controller接口来实现的，即只针对&#x2F;error进行处理，它会返回默认视图来渲染结果显示给用户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicErrorController</span> <span class="keyword">extends</span> <span class="title class_">AbstractErrorController</span> &#123; <span class="comment">// ..&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>
  </div>
  
    
      <a id="older" class="blog-nav" href="/Dubbo-SPI%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/">OLDER&nbsp;&gt;</a>
      
        
            
</div>
        <div class="footer">
  
    <div class="footer-more">
      
        <a href="/"><em style="color:red;">新站点正在开发中，网站暂停更新。</em></a>
        
    </div>
  
    <div class="footer-more">
      
        <a href="/">Copyright © DeeTam 2022</a>
        
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      
  <div class="search-icon" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-box">
        <div class="search-title">
          <!-- <span class="search-icon-input">
            <a href="javascript: void(0)">
              <i class="iconfont icon-search"></i>
            </a>
          </span> -->
          
            <input type="text" class="search-input" id="search-input" placeholder="搜索...">
          
          <span class="search-close-icon" id="search-close-icon">
            <a href="javascript: void(0)">
              <i class="iconfont icon-close"></i>
            </a>
          </span>
        </div>
        <div class="search-result" id="search-result"></div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    // inputArea.onclick = function() {
    //   getSearchFile()
    //   this.onclick = null
    // }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        inputArea.focus()
        getSearchFile()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'><span></ul>";
      // $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='/" + data_url + "' class='search-result-title'><h2>" + orig_data_title + "</h2></a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<h3 class=\"search-result-abstract\">" + match_content + "...</h3>"
                }
                str += "<hr></li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/leedom92/hexo-theme-leedom#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




    </div>
  </body>
</html>
